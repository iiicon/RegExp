// 正则表达式回溯法原理
// 正则表达式匹配字符串的这种方式，有个学名，叫回溯法。
// 回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，
// 当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。
// 这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。（copy于百度百科）。

// 本质上就是深度优先搜索算法。其中退到之前的某一步这一过程，我们称为“回溯”。

// 常见的回溯
// 1. 贪婪量词 ??
// 先下手为强！因为深度优先搜索 。。。
{
  const reg = /(\d{1,3})(\d{1,3})/;
  const string = "12345";
  // console.log(reg.exec(string))
  //   [ '12345',
  //   '123',
  //   '45',
  //   index: 0,
  // input: '12345',
  // groups: undefined ]
}

// 2. 惰性量词
{
  const reg = /(\d{1,3}?)(\d{1,3})/;
  const string = "12345";
  // console.log(reg.exec(string));
  // [ '1234', '1', '234', index: 0, input: '12345', groups: undefined ]
}
{
  // 回溯
  const reg = /^(\d{1,3}?)(\d{1,3})$/;
  const string = "12345";
  // console.log(reg.exec(string))
  //   [ '12345',
  //   '12',
  //   '345',
  //   index: 0,
  // input: '12345',
  // groups: undefined ]
}

// 3. 分支结构
{
  // 分支回溯
  const reg = /^(can|candy)$/;
  const string = "candy";
  // console.log(reg.exec(string));
}
// 既然有回溯的过程，那么匹配效率肯定低一些。相对谁呢？相对那些DFA引擎。
// 而JS的正则引擎是NFA，NFA是“非确定型有限自动机”的简写。

// 小结：
// 贪婪量词  惰性量词  分支结构  中不同的回溯
